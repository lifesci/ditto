use std::str::FromStr;
use crate::ast::*;

grammar;

// START TOKENS

// Arithmetic
t_Add: &'input str = "+";
t_Sub: &'input str = "-";
t_Mul: &'input str = "*";
t_Div: &'input str = "/";
t_Mod: &'input str = "%";

// Logic
t_And: &'input str = "and";
t_Or: &'input str = "or";
t_Not: &'input str = "not";
t_Equal: &'input str = "==";
t_Gt: &'input str = ">";
t_Lt: &'input str = "<";
t_Gte: &'input str = ">=";
t_Lte: &'input str = "<=";

// Numeric literals
t_Int: i32 = r"0|[1-9][0-9]*" => i32::from_str(<>).unwrap();
t_Float: f32 = r"(?:0|[1-9][0-9]*)\.[0-9]+" => f32::from_str(<>).unwrap();

// Boolean literals
t_True: bool = "true" => true;
t_False: bool = "false" => false;

// String literals
t_Str: String = r#""[^"]*""# => <>.to_string();

// Identifiers
t_Id: String = r"[a-zA-Z][a-zA-Z0-9_]*" => <>.to_string();

// Keywords
t_Let: &'input str = "let";
t_If: &'input str = "if";
t_Else: &'input str = "else";
t_While: &'input str = "while";
t_Player: &'input str = "player";
t_Enemy: &'input str = "enemy";
t_Action: &'input str = "action";
t_Targets: &'input str = "targets";
t_Trigger: &'input str = "trigger";
t_On: &'input str = "on";

// END TOKENS

// START GRAMMAR

pub Ditto: DittoNode = {
    <game: Game>
    <player: Player>
    <enemies: Enemy*>
    => DittoNode {<>},
}

Game: GameNode = {
    "game" <name: t_Id> ";" => GameNode {name: name}
};

Player: EntityNode = {
    t_Player <name: t_Id> "{" <stats: Stat*> <actions: Action*> <triggers: Trigger*> "}" => EntityNode {entity: EntityType::Player, <>}
}

Enemy: EntityNode = {
    t_Enemy <name: t_Id> "{" <stats: Stat*> <actions: Action*> <triggers: Trigger*> "}" => EntityNode {entity: EntityType::Enemy, <>}
}

Stat: StatNode = {
    <name: t_Id> "=" <val: Expr> ";" => StatNode {<>},
}

Action: ActionNode = {
    t_Action <name: t_Id> t_Targets "(" <targets: t_Id+> ")" "{" <children: StmtList> "}" => ActionNode {<>},
}

Trigger: TriggerNode = {
    t_Trigger <name: t_Id> t_On "(" <actions: t_Id+> ")" "{" <children: StmtList> "}" => TriggerNode {<>},
}

Stmt: Box<StmtEnum> = {
    t_Let <l: t_Id> "=" <r: Expr> ";" => Box::new(StmtEnum::Declare(DeclareNode {<>})),
    <l: t_Id> "=" <r: Expr> ";" => Box::new(StmtEnum::Assign(AssignNode {l: Box::new(AssignEnum::Var(l)), r: r})),
    <l: Property> "=" <r: Expr> ";" => Box::new(StmtEnum::Assign(AssignNode {l: Box::new(AssignEnum::Prop(l)), r: r})),
    t_While "(" <cond: Expr> ")" "{" <children: StmtList> "}" => Box::new(StmtEnum::While(WhileNode {<>})),
    <main: If> <alt: (t_Else <If>)*> <fin: Else> => Box::new(StmtEnum::Cond(CondNode {<>})),
}

StmtList: Vec<Box<StmtEnum>> = {
    Stmt*,
}

If: IfNode = {
    t_If "(" <cond: Expr> ")" "{" <children: Stmt*> "}" => IfNode {<>},
}

Else: Vec<Box<StmtEnum>> = {
    <branch: (t_Else "{" <StmtList> "}")?> => match branch {
        None => Vec::new(),
        Some(b) => b,
    }
};

Property: PropertyNode = {
    <var:t_Id> "." <prop:t_Id> => PropertyNode {var: var, prop: prop}
};

Expr: Box<ExprEnum> = {
    <l:Expr> t_Add <r:Factor> => Box::new(ExprEnum::BinOp(BinOpNode {op: BinOp::Add, <>})),
    <l:Expr> t_Sub <r:Factor> => Box::new(ExprEnum::BinOp(BinOpNode {op: BinOp::Sub, <>})),
    <l:Expr> t_Or <r:Factor> => Box::new(ExprEnum::BinOp(BinOpNode {op: BinOp::Or, <>})),
    <l:Expr> t_Equal <r:Factor> => Box::new(ExprEnum::BinOp(BinOpNode {op: BinOp::Equal, <>})),
    <l:Expr> t_Gt <r:Factor> => Box::new(ExprEnum::BinOp(BinOpNode {op: BinOp::Gt, <>})),
    <l:Expr> t_Lt <r:Factor> => Box::new(ExprEnum::BinOp(BinOpNode {op: BinOp::Lt, <>})),
    <l:Expr> t_Gte <r:Factor> => Box::new(ExprEnum::BinOp(BinOpNode {op: BinOp::Gte, <>})),
    <l:Expr> t_Lte <r:Factor> => Box::new(ExprEnum::BinOp(BinOpNode {op: BinOp::Lte, <>})),
    Factor,
}

Factor: Box<ExprEnum> = {
    <l:Factor> t_Mul <r:Unary> => Box::new(ExprEnum::BinOp(BinOpNode {op: BinOp::Mul, <>})),
    <l:Factor> t_Div <r:Unary> => Box::new(ExprEnum::BinOp(BinOpNode {op: BinOp::Div, <>})),
    <l:Factor> t_Mod <r:Unary> => Box::new(ExprEnum::BinOp(BinOpNode {op: BinOp::Mod, <>})),
    <l:Factor> t_And <r:Unary> => Box::new(ExprEnum::BinOp(BinOpNode {op: BinOp::And, <>})),
    <Unary>,
}

Unary: Box<ExprEnum> = {
    t_Sub <l:Term> => Box::new(ExprEnum::UnaryOp(UnaryOpNode {op:UnaryOp::Neg, <>})),
    t_Not <l:Term> => Box::new(ExprEnum::UnaryOp(UnaryOpNode {op:UnaryOp::Not, <>})),
    Term,
}

Term: Box<ExprEnum> = {
    "(" <Expr> ")",
    t_Int => Box::new(ExprEnum::Int(<>)),
    t_Float => Box::new(ExprEnum::Float(<>)),
    t_True => Box::new(ExprEnum::Bool(<>)),
    t_False => Box::new(ExprEnum::Bool(<>)),
    t_Str => Box::new(ExprEnum::Str(<>)),
    t_Id => Box::new(ExprEnum::Var(<>)),
    Property => Box::new(ExprEnum::Prop(<>)),
}

// END GRAMMAR
